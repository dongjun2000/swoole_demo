<?php

/**
 * 第一个PHP多进程程序
 *
 * PHP多进程是在开发业务逻辑层面，并行处理多个任务的一种开发方式，
 * 例如：需要给10万会员发送邮件，每个邮件需要处理1秒，如果是一个进程处理，就需要 10万 * 1秒才能处理完成，
 * 但是，如果开启多个进程同时处理，
 * 例如：10个进程，那只需要 10万 * 1 / 10秒就能处理完成，缩短了10倍的时间。
 *
 * php-fpm是fast-cgi的进程管理器，启动之后会启动多个fast-cgi进程，等待任务处理。
 * 在php-fpm软件层面，fast-cgi的多个进程就属于多个进程处理，但是，当用户发起请求，由nginx交给php-fpm处理请求时，
 * 在这个层面，每个请求其实只占有一个 php fast-cgi进程进行处理逻辑，对于运行业务逻辑的这个php进程来说，其实是单进程的。
 * 同理，当我们直接运行一个 php文件时，默认是只开启一个 php进程进行运行php的代码。
 *
 * 在传统web模式下，php一向都单进程处理业务逻辑，只有在 cli模式下，用于处理异步任务，作为网络服务器时，才可能用到多进程处理，
 * 所以，大部分phper都对php多进程的概念不熟悉。
 *
 * php中的多进程需要安装 pcntl 扩展，并且只能在 cli 模式下运行。
 *
 * pcntl_fork()：fork一个新的进程，这个函数比较特殊，会返回两次，
 *              在父进程中返回子进程ID，在子进程永远返回值为0，
 *              因为一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用 posix_getppid()就可以拿到父进程的ID。
 *
 * pcntl_waitpid()：回收子进程，防止僵尸进程。
 *              僵尸进程是当前子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。
 *              僵尸进程保存了进程的状态等信息，如果父进程一直不处理，该进程将会一直存在，占用系统进程表项，
 *              如果僵尸进程过多，导致系统没有可用的进程表项，于是再也无法运行其他的程序。
 *
 * posix_getpid()：可以获取当前的进程ID，还有一个getmypid()函数也可以获取进程ID。
 */


echo "当前主进程ID = " . posix_getpid() . PHP_EOL;

$pid = pcntl_fork();

if ($pid == 0) {
    // 子进程
    echo "子进程的ID = " . posix_getpid() . PHP_EOL;
    sleep(2);
    echo "我将要退出啦\n";
} elseif ($pid > 0) {
    // 父进程
    if ($exit_id = pcntl_waitpid($pid, $status, WUNTRACED)) {   // WUNTRACED：阻塞，等待子进程退出
        echo "子进程({$exit_id})退出\n";
    }
    echo "父进程ID = " . posix_getpid() . PHP_EOL;
} else {
    die('fork failed.');
}

